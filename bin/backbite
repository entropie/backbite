#!/usr/bin/env ruby
# -*- mode:ruby -*-

require 'pathname'

require 'lib/backbite'

include Backbite
tlog = nil

if af = ARGV.first and r = Backbite.register[af.to_sym]
  tlog = Backbite.register[ARGV.shift]
end

if tlog.nil? and Backbite.register.default?
  tlog = Tumblelog.new(*Backbite.register.default)
  warn "#{tlog.name} is not a valid repository." unless tlog.valid?
elsif Backbite.register.empty?
  warn "no tumblogs known"
else
  warn "there's no default tumblog"
end

op = Backbite.optionparser do |op|

  op.keyword(:help) do |op, handler|
    op.desc "The help!"

    op.declare(:index, 'this screen') {
      puts op.to_s
    }
  end
  
  op.keyword(:plugin, Backbite::Plugins) do |op, handler|
    op.declare(:generate) { |name|
      puts Generators.generate(name, handler)
    }
  end

  if tlog
    op.keyword(:generator) do |op, handler|
      op.desc "generate files"
      Generators.generators do |name, gen|
        op.declare(name.to_sym, "generates a new skelleton for #{name} named <name>") { |name|
          raise "need a name for the generator" unless name
          puts Generators.generate(name, gen)
        }
      end
    end
    
    if tlog.valid?

      op.keyword(:components, tlog.components) do |op, handler|
        op.desc "create and manage components (ways to post)"
        op.declare(:ls, "lists components attached to the tumblog") {
          puts handler
        }
        op.declare(:generate, "generates a new component skelleton named <name>") { |name|
          puts tlog.components.generate(tlog, name)
        }
      end

      op.keyword(:post, tlog.posts) do |op, handler|
        op.desc "list, post and edit posts"

        op.declare(:to, 'post to <component> [way] to the tumblog') { |c,w|
          puts tlog.post(c.to_sym, :way => w).save
        }
        
        op.declare(:ls, "lists pending posts") {|*args|
          args = args.first if args and not args.empty?
          nargs =
          case args
          when nil
            { }
          when /(\d+)\.\.(\d+)/
            { :ids => Range.new($1.to_i, $2.to_i).to_a }
          when /(\d+)/
            { :ids => $1.to_i }
          when /^(\w+)/
            { :tags =>
              if args.include?(',')
                args.split(',')
              else
                [$1]
              end
            }
          when /^:(\w+)/
            { :target => $1.to_sym }
          else
            { }
          end

          handler.filter(nargs) do |r|
            puts r
            puts
          end
        }
      end
    end
  end

  op.keyword(:tlog, tlog) do |op, handler|

    op.desc "everything about your tumblog"

    op.declare(:generate, "generates a config skeleton in <file>") { |file|
      puts Generators.generate(file, Tumblelog)
    }

    op.declare(:setup, "lists tlog registers") {
      puts handler.repository.setup!
    }

    op.declare(:clean, 'clean the repository (eg. flushes tempfiles)'){ 
      puts "%i files removed".bold % handler.repository.clean!
    }
    
    op.declare(:lsr, "lists tlog registers") {
      puts handler.register
    }
    
    op.declare(:register, "register tlog with <name> and <configfile>") {|name, cfgf|
      if name and cfgf
        tlog = Tumblelog.new(name.to_sym, cfgf)
        Backbite.register[tlog.name] = cfgf
      end
      puts register
    }

    op.declare(:default, "set <default> tumblog"){ |*default|
      unless default.empty?
        default = default.shift
        
        d = default.to_sym
        cfg = Backbite.register[d]
        tlog = Tumblelog.new(default.to_sym, cfg)
        Backbite.register.default = tlog
      end
      puts register
    }

    if handler
      op.declare(:ls, "basic information") {
        puts handler.repository
      }
      op.declare(:url, "the url to your tumblog") {
        puts handler.url
      }
      op.declare(:ways, "list the ways to post to the tumblog") {
        puts handler.repository.export.ways.map(&:to_s).map(&:bold).join(',')
      }

      op.declare(:export, "export your tumblog <how>") { |*how|
        if not how or how.empty? or how.to_s == 'all'
          how = handler.repository.export.ways.join(',')
        end
        nhow = if how.to_s =~ /,/
                 how.to_s.split(',').map(&:strip).flatten
               else [how] end
        nhow.map(&:to_sym).each do |h|
          handler.repository.export(h)
        end
        
      }
    end
  end


end

begin
  op.parse(*ARGV.dup)
rescue GetReal => e
  puts e.inspect
end



